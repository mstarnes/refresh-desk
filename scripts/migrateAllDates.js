// scripts/migrateAllDates.js
// generated by grok 4
// not executed because importData.js works
const mongoose = require('mongoose');
const Ticket = require('../models/Ticket');

async function migrate() {
  await mongoose.connect('mongodb://localhost/refreshdesk', { useNewUrlParser: true, useUnifiedTopology: true });

  const tickets = await Ticket.find({});
  for (const ticket of tickets) {
    let needsSave = false;

    // Top-level dates
    if (typeof ticket.created_at === 'string') {
      const date = new Date(ticket.created_at);
      if (!isNaN(date)) {
        ticket.created_at = date;
        needsSave = true;
      } else {
        console.warn(`Invalid created_at for ticket ${ticket._id}: ${ticket.created_at}`);
      }
    }
    // Repeat for due_by, fr_due_by, nr_due_by, etc.
    if (typeof ticket.due_by === 'string') {
      const date = new Date(ticket.due_by);
      if (!isNaN(date)) {
        ticket.due_by = date;
        needsSave = true;
      } else {
        console.warn(`Invalid due_by for ticket ${ticket._id}: ${ticket.due_by}`);
      }
    }
    if (typeof ticket.fr_due_by === 'string') {
      const date = new Date(ticket.fr_due_by);
      if (!isNaN(date)) {
        ticket.fr_due_by = date;
        needsSave = true;
      } else {
        console.warn(`Invalid fr_due_by for ticket ${ticket._id}: ${ticket.fr_due_by}`);
      }
    }

    // ticket_states subdoc
    if (ticket.ticket_states) {
      if (typeof ticket.ticket_states.created_at === 'string') {
        const date = new Date(ticket.ticket_states.created_at);
        if (!isNaN(date)) {
          ticket.ticket_states.created_at = date;
          needsSave = true;
        } else {
          console.warn(`Invalid ticket_states.created_at for ticket ${ticket._id}`);
        }
      }
      if (typeof ticket.ticket_states.updated_at === 'string') {
        const date = new Date(ticket.ticket_states.updated_at);
        if (!isNaN(date)) {
          ticket.ticket_states.updated_at = date;
          needsSave = true;
        } else {
          console.warn(`Invalid ticket_states.updated_at for ticket ${ticket._id}`);
        }
      }
      // Repeat for resolution_time_updated_at, status_updated_at, assigned_at, pending_since
      if (typeof ticket.ticket_states.assigned_at === 'string') {
        const date = new Date(ticket.ticket_states.assigned_at);
        if (!isNaN(date)) {
          ticket.ticket_states.assigned_at = date;
          needsSave = true;
        } else {
          console.warn(`Invalid ticket_states.assigned_at for ticket ${ticket._id}`);
        }
      }
      // Add others as needed
    }

    // requester subdoc
    if (ticket.requester) {
      if (typeof ticket.requester.created_at === 'string') {
        const date = new Date(ticket.requester.created_at);
        if (!isNaN(date)) {
          ticket.requester.created_at = date;
          needsSave = true;
        } else {
          console.warn(`Invalid requester.created_at for ticket ${ticket._id}`);
        }
      }
      if (typeof ticket.requester.updated_at === 'string') {
        const date = new Date(ticket.requester.updated_at);
        if (!isNaN(date)) {
          ticket.requester.updated_at = date;
          needsSave = true;
        } else {
          console.warn(`Invalid requester.updated_at for ticket ${ticket._id}`);
        }
      }
    }

    if (needsSave) {
      await ticket.save();
    }
  }

  console.log('Migration complete');
  mongoose.disconnect();
}

migrate().catch(err => console.error(err));